//go:build ignore

package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"text/template"
	"time"
)

var (
	wikidata = "https://query.wikidata.org/sparql?query=%s"
	query    = `
		SELECT ?marc ?iso639 ?en ?nb
		WHERE
			{
				?lang wdt:P220 ?iso639 .
				?lang wdt:P4801 ?_marc .
				BIND(substr(lcase(?_marc), 11) AS ?marc)
				?lang rdfs:label ?en FILTER (lang(?en) = "en").
				OPTIONAL { ?lang rdfs:label ?nb FILTER (lang(?nb) = "nb"). }
			} ORDER BY ?marc
	`
	tmpl = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}
// using data from https://www.wikidata.org
package marc

import (
	"errors"
	"golang.org/x/text/language"
	"github.com/knakk/sirkulator/internal/localizer"
)

//go:generate go run gen_language.go
//go:generate go fmt language.go

var languages = map[string][2]string{
{{- range $row :=  .Languages }}
	{{ index $row 0 | printf "%q" }}: {{"{"}}{{ index $row 2 | printf "%q" }}, {{ index $row 3 | printf "%q" }}{{"}"}},
{{- end }}
}

var diffCodes = map[string]string{
	{{- range $row :=  .Diff }}
		{{ index $row 0 | printf "%q" }}: {{ index $row 1 | printf "%q"}},
	{{- end }}
	}

// Language is a known Marc language, associated with a 3-letter code.
// The codes are maintained by Library of Congress.
type Language struct {
	code string
}

// ParseLanguage parses the given string and returns a Language if
// it matches a known 3-letter Marc language code.
func ParseLanguage(s string) (Language, error) {
	if _, ok := languages[s]; ok {
		return Language{code: s}, nil
	}
	return Language{}, errors.New("marc: unknown language")
}

// Code returns the Marc language code for the Language.
func (l Language) Code() string {
	return l.code
}

// ISO3 returns the ISO 639-3 language code which corresponds to the Marc language.
// In all but a few cases, the ISO and Marc codes are identical.
func (l Language) ISO3() string {
	if code, ok := diffCodes[l.code]; ok {
		return code
	}
	return l.code
}

// Label returns a string representation of the Marc Language in the desired language.
// Only Norwegian and English are currently supported. If a Norwegian label is required and
// not present, the English label will be returned.
func (l Language) Label(tag language.Tag) string {
	match, _, _ := localizer.Matcher.Match(tag)
	if match == language.Norwegian && languages[l.code][1] != "" {
		return languages[l.code][1]
	}
	return languages[l.code][0]
}

	`))
)

func main() {
	req, err := http.NewRequest(http.MethodGet, fmt.Sprintf(wikidata, url.QueryEscape(query)), nil)
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("Accept", "text/csv")
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer res.Body.Close()

	r := csv.NewReader(res.Body)
	r.FieldsPerRecord = 4 // marc, iso639, en, nb

	var recs [][]string
	var diff [][2]string

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			log.Fatal(err)
		}
		switch rec[1] {
		case "iso639":
			// Skip header row.
			continue
		case "pnb", "lvs", "ekk":
			// Skip known deprecated or wrongly mapped codes in wikidata.
			continue
		}

		if rec[0] != rec[1] {
			diff = append(diff, [2]string{rec[0], rec[1]})
		}

		// Lowercase and trim " (språk)" suffix from the Norwegian label.
		rec[3] = strings.ToLower(strings.TrimSuffix(rec[3], " (språk)"))
		recs = append(recs, rec)
	}

	f, err := os.Create("language.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, struct {
		Timestamp string
		Languages [][]string
		Diff      [][2]string
	}{
		Timestamp: time.Now().Format(time.RFC3339),
		Languages: recs,
		Diff:      diff,
	}); err != nil {
		log.Fatal(err)
	}

}

//go:build ignore

package main

import (
	"encoding/xml"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

const url = "http://www.isbn-international.org/export_rangemessage.xml"
const header = `// Code generated by go generate; DO NOT EDIT.
package isbn

//go:generate go run gen_ranges.go
//go:generate gofumpt -w ranges.go

type isbnRange struct {
	Prefix string
	Agency string
	Ranges [][2]string
}

var ranges = map[string]isbnRange{`
const footer = `
}
`

type group struct {
	Prefix string
	Agency string
	Rules  []rule `xml:">Rule"`
}

type rule struct {
	Range  string
	Length string
}

func main() {
	res, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer res.Body.Close()

	dec := xml.NewDecoder(res.Body)

	var groups []group
	for {
		t, err := dec.Token()
		if err != nil && err != io.EOF {
			log.Fatal(err)
		}
		if t == nil {
			break
		}
		switch elem := t.(type) {
		case xml.StartElement:
			if elem.Name.Local == "Group" {
				var g group
				dec.DecodeElement(&g, &elem)
				groups = append(groups, g)
			}
		}
	}

	f, err := os.Create("ranges.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintln(f, header)
	for _, g := range groups {
		fmt.Fprintf(f, "%q: {\n", g.Prefix[4:])
		fmt.Fprintf(f, "\tPrefix: %q,\n", g.Prefix[:3])
		fmt.Fprintf(f, "\tAgency: %q,\n", g.Agency)
		fmt.Fprintf(f, "\tRanges: [][2]string{")
		for _, r := range g.Rules {
			if r.Length == "0" {
				continue
			}
			l, _ := strconv.Atoi(r.Length)
			ranges := strings.Split(r.Range, "-")
			fmt.Fprintf(f, "{%q,%q},", ranges[0][:l], ranges[1][:l])
		}
		fmt.Fprintf(f, "\t},")
		fmt.Fprintf(f, "\t},\n")

	}
	fmt.Fprintln(f, footer)
}

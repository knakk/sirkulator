//go:build ignore

package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"text/template"
	"time"
)

var (
	wikidata = "https://query.wikidata.org/sparql?query=%s"
	query    = `
		SELECT ?marc ?iso639 ?en ?nb
		WHERE
			{
				?lang wdt:P220 ?iso639 .
				?lang wdt:P4801 ?_marc .
				BIND(substr(lcase(?_marc), 11) AS ?marc)
				?lang rdfs:label ?en FILTER (lang(?en) = "en").
				OPTIONAL { ?lang rdfs:label ?nb FILTER (lang(?nb) = "nb"). }
			} ORDER BY ?marc
	`
	tmpl = template.Must(
		template.New("").Funcs(template.FuncMap{"mod": func(i, j int) bool { return i%j == 0 }}).
			Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}
// using data from https://www.wikidata.org
package iso6393

import (
	"fmt"
	"sort"

	"golang.org/x/text/language"
	"github.com/knakk/sirkulator/internal/localizer"
)

//go:generate go run gen_language.go
//go:generate go fmt language.go

// Language is a iso 639-3 language, represented by a 3-letter code.
type Language string

const (
{{- range $row :=  .Languages }}
	{{ index $row 4 }} Language = {{ index $row 1 | printf "%q" }}
{{- end }}
)

var allLanguages = []Language{
{{- range $i, $row :=  .Languages }}
	{{- if mod $i 20 -}}{{" "}}
	{{ end -}}
	{{- index $row 4 -}},
{{- end }}
}

var languageLabels = map[Language][2]string{
{{- range $row :=  .Languages }}
	{{ index $row 4 }}: {{"{"}}{{ index $row 2 | printf "%q" }}, {{ index $row 3 | printf "%q" }}{{"}"}},
{{- end }}
}

var marcToLanguage = map[string]Language{
	{{- range $row :=  .Diff }}
		{{ index $row 1 | printf "%q"}}: {{ index $row 0}},
	{{- end }}
	}

var diffCodes = map[Language]string{
	{{- range $row :=  .Diff }}
		{{ index $row 0 }}: {{ index $row 1 | printf "%q" }},
	{{- end }}
	}


// ParseLanguageFromMarc parses the given string and returns a Language if
// it matches a known 3-letter Marc language code.
func ParseLanguageFromMarc(s string) (Language, error) {
	if lang, ok := marcToLanguage[s]; ok {
		return lang, nil
	}

	return ParseLanguage(s)
}

// ParseLanguage parses the given string and returns a Language if
// it matches a known 3-letter ISO 639-3 language code.
func ParseLanguage(s string) (Language, error) {
	if _, ok := languageLabels[Language(s)]; ok {
		return Language(s), nil
	}
	return "", fmt.Errorf("iso6393: unknown language code: %q", s)
}

// Code returns the ISO 639-3 language code for the Language.
func (l Language) Code() string {
	return string(l)
}

func (l Language) URI() string {
	return "iso6393/"+string(l)
}

// MarcCode returns the Marc language code for the Language.
// In all but a few cases, the ISO and Marc codes are identical.
func (l Language) MarcCode() string {
	if code, ok := diffCodes[l]; ok {
		return code
	}
	return string(l)
}

// Label returns a string representation of the Marc Language in the desired language.
// Only Norwegian and English are currently supported. If a Norwegian label is required and
// not present, the English label will be returned.
func (l Language) Label(tag language.Tag) string {
	match, _, _ := localizer.Matcher.Match(tag)
	if match == language.Norwegian && languageLabels[l][1] != "" {
		return languageLabels[l][1]
	}
	return languageLabels[l][0]
}

func Options(lang language.Tag) (res [][2]string) {
	match, _, _ := localizer.Matcher.Match(lang)
	i := 0
	if match == language.Norwegian {
		i = 1
	}
	for _, c := range allLanguages {
		label := languageLabels[c][i]
		if label == "" {
			// Fallback to English if missing Norwegian label
			label = languageLabels[c][0]
		}
		res = append(res, [2]string{string(c), label})
	}

	// Sort by label
	sort.Slice(res, func(i, j int) bool {
		return res[i][1] < res[j][1]
	})

	return res
}

	`))
)

func main() {
	req, err := http.NewRequest(http.MethodGet, fmt.Sprintf(wikidata, url.QueryEscape(query)), nil)
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("Accept", "text/csv")
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer res.Body.Close()

	r := csv.NewReader(res.Body)
	r.FieldsPerRecord = 4 // marc, iso639, en, nb

	var recs [][]string
	var diff [][2]string

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			log.Fatal(err)
		}
		switch rec[1] {
		case "iso639":
			// Skip header row.
			continue
		case "pnb", "lvs", "ekk":
			// Skip known deprecated or wrongly mapped codes in wikidata.
			continue
		}

		if rec[0] != rec[1] {
			diff = append(diff, [2]string{strings.ToUpper(rec[1]), rec[0]})
		}
		// Trim " (språk)" suffix from the Norwegian label.
		rec[3] = strings.TrimSuffix(rec[3], " (språk)")
		rec = append(rec, strings.ToUpper(rec[1])) // ALL CAPS for Language constant name
		recs = append(recs, rec)
	}

	f, err := os.Create("language.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, struct {
		Timestamp string
		Languages [][]string
		Diff      [][2]string
	}{
		Timestamp: time.Now().Format(time.RFC3339),
		Languages: recs,
		Diff:      diff,
	}); err != nil {
		log.Fatal(err)
	}

}

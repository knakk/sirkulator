//go:build ignore

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

type TermList struct {
	Entries []struct {
		Schema string `json:"inSchema"`
		ID     string `json:"@id"`
		Type   string `json:"@type"` // ignore entry if type="ConceptScheme"
		Label  struct {
			NO string `json:"no"`
			EN string `json:"en"`
		} `json:"prefLabel"`
		Note struct {
			NO []string `json:"no"`
			EN []string `json:"en"`
		} `json:"note"`
		Definition struct {
			NO string `json:"no"`
			EN string `json:"en"`
		} `json:"ToolkitDefinition"`
		Notation struct {
			EN string `json:"en"`
		} `json:"notation"`
		Status struct {
			Label string `json:"label"` // check for "Deprecated"
		} `json:"status"`
	} `json:"@graph"`
}

var tmpl = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}
// using data from the RDA Registry maintained by the RDA Steering Committee (http://www.rda-rsc.org/)
package rda

import (
	"golang.org/x/text/language"
	"github.com/knakk/sirkulator/vocab"
	"github.com/knakk/sirkulator/internal/localizer"
)

//go:generate go run gen_codes.go

var labels{{.Code}} = map[string][2]string{
{{- range $row :=  .Terms }}
	{{ index $row 0 | printf "%q" }}: {{"{"}}{{ index $row 1 | printf "%q" }}, {{ index $row 2 | printf "%q" }}{{"}"}},
{{- end }}
}

var deprecated{{.Code}} = map[string]string{
{{- range $row :=  .Deprecated}}
	{{ index $row 0 | printf "%q" }}: {{ index $row 1 | printf "%q" }},
{{- end }}
}


// {{.Code}} is a RDA Term Code.
type {{.Code}} string


func (t {{.Code}}) Code() string {
	return string(t)
}

func (t {{.Code}}) URI() string {
	return "http://rdaregistry.info/termList/RDA{{.TermList}}/" + string(t)
}

func (t {{.Code}}) Label(tag language.Tag) string {
	match, _, _ := localizer.Matcher.Match(tag)
	if match == language.Norwegian && labels{{.Code}}[string(t)][1] != "" {
		return labels{{.Code}}[string(t)][1]
	}
	return labels{{.Code}}[string(t)][0]
}

func Parse{{.Code}} (s string) ({{.Code}}, error) {
	if _, ok := labels{{.Code}}[s]; ok {
		return {{.Code}}(s), nil
	}
	if _, ok := deprecated{{.Code}}[s]; ok {
		return {{.Code}}("unknown"), vocab.ErrDeprecated
	}
	return {{.Code}}("unknown"), vocab.ErrUnknown
}

	`))

func writeFile(code, list string) {
	url := fmt.Sprintf("https://raw.githubusercontent.com/RDARegistry/RDA-Vocabularies/master/jsonld/termList/RDA%s.jsonld", list)
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	var terms TermList
	if err := json.NewDecoder(resp.Body).Decode(&terms); err != nil {
		log.Fatal(err)
	}
	f, err := os.Create(strings.ToLower(code) + ".go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	var recs [][3]string
	var depr [][2]string
	for _, e := range terms.Entries {
		if e.Type == "ConceptScheme" {
			continue
		}
		c := strings.TrimPrefix(e.ID, fmt.Sprintf("http://rdaregistry.info/termList/RDA%s/", list))
		if e.Status.Label == "Deprecated" {
			depr = append(depr, [2]string{c, e.Label.EN})
		} else {
			recs = append(recs, [3]string{c, e.Label.EN, e.Label.NO})
		}
	}

	if err := tmpl.Execute(f, struct {
		Timestamp  string
		Code       string
		TermList   string
		Terms      [][3]string
		Deprecated [][2]string
	}{
		Code:       code,
		TermList:   list,
		Timestamp:  time.Now().Format(time.RFC3339),
		Terms:      recs,
		Deprecated: depr,
	}); err != nil {
		log.Fatal(err)
	}

}

func main() {
	genCodes := []struct {
		Code     string
		TermList string
	}{
		{
			Code:     "CO",
			TermList: "ContentType",
		},
		{
			Code:     "CT",
			TermList: "CarrierType",
		},
		{
			Code:     "MT",
			TermList: "MediaType",
		},
		{
			Code:     "TB",
			TermList: "TypeOfBinding",
		},
	}

	for _, g := range genCodes {
		writeFile(g.Code, g.TermList)
	}

}
